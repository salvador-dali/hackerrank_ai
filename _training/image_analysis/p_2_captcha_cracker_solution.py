"""
Main idea for this task
 - color information is redundant. 0/1 map is more than enough
 - remove irrelevant border from the image
 - analyse the images to extract the statistics for each digit in the image
 - after this run each digit through comparison process against other digits, whose statistics we
 already calculated
"""

import numpy as np

def matrixTransform(M):
    """ Binarize the matrix.
    Everything smaller than some threshold is 0, above another threshold is 1
    Here I was stupid and the thresholds are not the same. Next time I would not be as stupid

    I also shop some parts of the matrix because it is not used
    :param M:
    :return:
    """
    M[M > 150] = 256
    M[M < 50] = 0
    return M[10:-8, 4:-11]

def predictDigit(digit_stats, digit):
    # these are precalculated predictions which I collected from the investigation phase
    predictions = {'1': [200.53333333333333, 171.84444444444443, 143.86666666666667, 200.37777777777779, 199.93333333333334, 199.17777777777778, 200.44444444444443, 199.77777777777777, 199.71111111111111, 87.088888888888889], '0': [199.88888888888889, 142.5, 143.0, 143.66666666666669, 143.0, 143.11111111111111, 144.72222222222223, 144.5, 143.38888888888889, 199.33333333333331], '3': [116.72222222222223, 144.38888888888889, 200.22222222222223, 200.22222222222223, 171.33333333333331, 199.11111111111111, 199.16666666666669, 200.72222222222223, 143.33333333333331, 116.27777777777777], '2': [145.04444444444445, 143.73333333333335, 143.04444444444445, 200.31111111111107, 199.40000000000001, 200.40000000000001, 200.26666666666668, 199.80000000000001, 199.55555555555557, 31.377777777777784],'5': [59.222222222222221, 200.07407407407405, 199.85185185185185, 116.11111111111113, 114.55555555555556, 199.77777777777774, 200.62962962962965, 144.92592592592595, 143.74074074074073, 143.92592592592595], '4': [199.11111111111111, 172.61111111111109, 143.27777777777777, 143.88888888888889, 143.0, 144.16666666666669, 33.277777777777779, 199.55555555555554, 199.55555555555554, 199.88888888888889], '7': [31.611111111111114, 199.72222222222223, 199.97222222222223, 199.97222222222223, 199.63888888888889, 199.75, 200.27777777777777, 201.38888888888889, 199.4722222222222, 200.08333333333331], '6': [143.55555555555554, 143.7777777777778, 172.03703703703704, 199.7777777777778, 115.48148148148148, 114.7037037037037, 144.59259259259258, 144.0, 143.5185185185185, 143.7037037037037], '9': [143.9111111111111, 143.44444444444443, 143.62222222222221, 144.55555555555557, 114.97777777777779, 114.91111111111111, 200.77777777777777, 172.82222222222225, 144.02222222222221, 143.97777777777779], '8': [145.0, 143.77777777777777, 142.55555555555554, 144.0, 142.33333333333334, 143.44444444444446, 144.77777777777777, 145.88888888888889, 143.66666666666666, 145.0], 'A': [199.7222222222222, 143.38888888888889, 143.63888888888891, 143.80555555555554, 142.97222222222223, 143.02777777777777, 31.333333333333332, 143.61111111111111, 144.58333333333331, 142.80555555555557], 'C': [114.66666666666667, 144.46666666666667, 171.97777777777776, 200.08888888888887, 199.95555555555555, 199.82222222222222, 199.39999999999998, 171.86666666666665, 143.73333333333332, 115.04444444444444], 'B': [88.407407407407405, 144.37037037037038, 144.25925925925927, 143.07407407407408, 87.8888888888889, 143.33333333333334, 143.59259259259261, 143.92592592592595, 143.40740740740742, 87.8888888888889], 'E': [60.240740740740733, 199.61111111111111, 199.83333333333334, 199.62962962962959, 87.129629629629619, 199.25925925925927, 200.9814814814815, 199.46296296296296, 200.90740740740739, 60.425925925925924], 'D': [87.222222222222214, 143.9111111111111, 144.46666666666667, 143.79999999999998, 143.80000000000001, 142.88888888888889, 143.86666666666667, 144.93333333333334, 143.51111111111112, 87.555555555555557], 'G': [116.0, 143.64444444444445, 199.88888888888889, 199.9111111111111, 200.11111111111111, 115.37777777777778, 143.71111111111111, 143.44444444444443, 143.86666666666667, 115.08888888888889], 'F': [34.111111111111114, 200.44444444444446, 199.11111111111111, 200.0, 87.888888888888886, 199.77777777777777, 199.33333333333334, 200.22222222222223, 199.11111111111111, 200.44444444444446], 'I': [87.555555555555557, 201.11111111111111, 200.77777777777777, 199.11111111111111, 199.22222222222223, 200.11111111111111, 199.16666666666669, 199.5, 199.11111111111111, 87.388888888888886], 'H': [144.44444444444446, 143.58333333333331, 144.27777777777777, 144.44444444444446, 30.75, 143.08333333333331, 144.41666666666666, 143.63888888888889, 143.05555555555554, 143.83333333333331], 'K': [144.40740740740739, 145.44444444444443, 143.33333333333334, 143.74074074074076, 143.70370370370372, 143.03703703703704, 143.2222222222222, 146.18518518518519, 143.37037037037038, 144.18518518518519], 'J': [143.55555555555557, 199.44444444444446, 200.25925925925924, 200.14814814814812, 199.40740740740739, 199.77777777777774, 200.07407407407405, 171.33333333333334, 145.0, 171.96296296296296], 'M': [144.31111111111113, 87.777777777777771, 31.733333333333338, 88.0, 87.355555555555554, 86.422222222222217, 142.66666666666669, 144.48888888888888, 143.80000000000001, 143.3111111111111], 'L': [199.2962962962963, 200.2222222222222, 199.2962962962963, 200.2962962962963, 200.25925925925927, 199.62962962962965, 200.66666666666666, 199.88888888888889, 200.0, 60.25925925925926], 'O': [143.81481481481481, 143.55555555555554, 144.5185185185185, 143.46296296296296, 144.07407407407408, 142.79629629629628, 144.35185185185185, 143.16666666666669, 144.94444444444443, 143.74074074074073], 'N': [143.11111111111111, 115.66666666666667, 89.444444444444443, 85.888888888888886, 86.777777777777771, 88.333333333333329, 86.111111111111114, 117.77777777777777, 115.22222222222223, 146.44444444444446], 'Q': [143.22222222222223, 144.88888888888886, 144.84444444444446, 143.59999999999999, 143.15555555555557, 142.77777777777777, 88.75555555555556, 87.377777777777766, 144.84444444444446, 115.59999999999999], 'P': [59.111111111111114, 144.44444444444446, 144.77777777777777, 142.22222222222223, 58.0, 199.88888888888889, 199.11111111111111, 201.33333333333334, 199.11111111111111, 199.88888888888889], 'S': [88.250000000000014, 143.72222222222223, 199.36111111111111, 199.77777777777777, 87.055555555555557, 199.72222222222223, 199.83333333333334, 199.88888888888891, 143.77777777777777, 86.555555555555557], 'R': [60.851851851851848, 144.2962962962963, 143.40740740740742, 145.0, 59.703703703703695, 114.96296296296298, 144.62962962962965, 143.0, 143.74074074074073, 144.37037037037035], 'U': [143.38888888888891, 143.83333333333334, 142.61111111111111, 145.44444444444446, 143.0, 142.88888888888889, 144.5, 143.33333333333334, 144.88888888888889, 144.27777777777777], 'T': [31.944444444444446, 200.16666666666666, 200.0, 199.72222222222223, 199.38888888888889, 199.11111111111111, 199.33333333333331, 200.0, 199.55555555555554, 199.66666666666666], 'W': [143.77777777777777, 143.36111111111111, 142.75, 144.77777777777777, 86.833333333333343, 87.416666666666671, 88.527777777777771, 31.166666666666664, 88.111111111111114, 144.13888888888889], 'V': [143.61904761904762, 144.0952380952381, 144.0952380952381, 143.66666666666669, 143.52380952380952, 143.93650793650792, 144.0952380952381, 144.47619047619048, 199.92063492063491, 199.69841269841268], 'Y': [144.16666666666669, 143.0, 145.11111111111111, 144.11111111111109, 199.88888888888889, 199.61111111111111, 199.33333333333331, 199.66666666666669, 199.55555555555554, 200.66666666666666], 'X': [143.77777777777777, 143.16666666666669, 143.72222222222223, 145.0, 200.11111111111111, 199.55555555555554, 142.94444444444446, 143.83333333333331, 144.33333333333331, 142.77777777777777], 'Z': [59.822222222222216, 200.24444444444444, 200.22222222222223, 200.02222222222221, 199.57777777777775, 199.42222222222222, 200.46666666666664, 200.71111111111108, 197.35555555555555, 61.222222222222214]}

    # iterates over all letters and trying to find the one which has the smallest discrepancy
    # discrepancy is calculates as a MRSE
    bestScore = (float('inf'), None)
    for letter, stat in predictions.iteritems():
        score = (np.sum((np.array(stat) - digit_stats)**2) / 10) ** 0.5
        bestScore = min(bestScore, (score, letter))

    letter = bestScore[1]
    # now some of the letters have almost the same statistics
    # one group consists of KOU8 digits
    if letter in {'O', 'U', '8', 'K'}:
        if np.sum(digit[1:-1, 1:3]) == 0:
            return 'K'

        if 80 < np.average(digit[4:7, 2:-2]) < 90:
            return "8"

        if np.average(digit[0:2, 0:3]) == 256:
            return "O"

        if np.average(digit[0:2, 3:-3]) == 256:
            return "U"

    # another group is T7 digits
    if letter in {'T', '7'}:
        if np.sum(digit[1:4,-2:]) == 0:
            return '7'
        return 'T'

    return letter

def predict():
    """
    Reading the image from the stdin, chopping and removing the background
    then dividing the image into 5 digits and finding the best suitable digit based on
    the fingerprint

    :return: the letters
    """
    result = ''
    y, x = map(int, raw_input().split())
    # this was a mistake, here I am reading only the fist color from the matrix,
    # should have read it and transformed to greyscale
    M = matrixTransform(np.array([[int(el.split(',')[0]) for el in raw_input().split(' ')] for i in xrange(y)]))
    for i in xrange(5):
        digit = M[:, i*9:(i+1) * 9]
        digit_stats = np.average(digit, axis=1)[1:-1]
        result += predictDigit(digit_stats, digit)

    return result

if __name__ == '__main__':
    print predict()